# TCP/IP
### TCP、UDP对比
![Image](https://user-images.githubusercontent.com/91466593/144747642-cf5a8eb8-744d-4f7d-8cb7-b0855ce50cac.jpg)
1. UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。
2. TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。
3. TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。
4. TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。
### TCP在建立连接后，它在传输的时候有什么特点，怎么实现可靠传输。
![Image](https://user-images.githubusercontent.com/91466593/144747660-8bd67bae-edb2-421f-97f3-d4dcd599d622.png)
1. 应用数据被分割成 TCP 认为最适合发送的数据块。
2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
3. 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
4. TCP 的接收端会丢弃重复的数据。
5. 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）？、？通过返回接受窗口大小来实现控制 
![Image](https://user-images.githubusercontent.com/91466593/144747683-63d06e9a-9f03-4fbe-95fb-370622f4c928.png)
6. 拥塞控制： 当网络拥塞时，减少数据的发送。慢开始，拥塞避免，快重传，快恢复
![Image](https://user-images.githubusercontent.com/91466593/144747890-731b5afc-a860-45ba-9687-ad62ba65bd72.png)
7. ARQ 协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8. 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
### 三次握手、四次挥手。
#### 三次握手
![Image](https://user-images.githubusercontent.com/91466593/144747723-bb657f79-85a2-41c1-ae32-9cd7fdc22db3.png)
1. 初始状态：客户端处于 closed(关闭)状态，服务器处于 listen(监听) 状态。
2. 第一次握手：客户端发送请求报文将 SYN = 1同步序列号和初始化序列号seq = x发送给服务端，发送完之后客户端处于SYN_Send状态。（验证了客户端的发送能力和服务端的接收能力）
3. 第二次握手：服务端受到 SYN 请求报文之后，如果同意连接，会以自己的同步序列号SYN(服务端) = 1、初始化序列号 seq = y和确认序列号（期望下次收到的数据包）ack = x+ 1 以及确认号ACK = 1报文作为应答，服务器为SYN_Receive状态。
4. 第三次握手： 客户端接收到服务端的 SYN + ACK之后，知道可以下次可以发送了下一序列的数据包了，然后发送同步序列号 ack = y + 1和数据包的序列号 seq = x + 1以及确认号ACK = 1确认包作为应答，客户端转为established状态。（分别站在双方的角度上思考，各自ok）
三次握手原因：1，第2次握手只能客户端确认自己发送接受数据没问题，但是服务器无法确认自己发送能力没问题  

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列，当完成三次握手，才会进入全链接队列，syn-ack重传，如果第三次握手没有回来，就会间隔一段时间再重传（时间指数增长），如果超过最大重传次数，从半连接队列离开
* 三次握手只有第三次能携带数据，SYN攻击就是利用2次握手不回应，不断增加服务器资源
#### 四次挥手
![Image](https://user-images.githubusercontent.com/91466593/144747792-2d71e9e7-ff6b-46cd-bb38-da458c5af5e1.png)
1. 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。 即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。
2. 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。 即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
3. 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。 即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
4. 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。
* 2MSL等待状态：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）
### TCP中滑动窗口的作用是什么？能详细展开具体的过程
TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。
### 哪些场景需要用UDP协议
一般用于即时通信，比如： QQ 语音、 QQ 视频 、直播等等
### 像直播，如果它的数据包的顺序错了之后对直播的画面有什么影响。
### 快速重传机制
如果收到3个连同样的ACK，TCP就会立刻重传（快速重传），不然就要等超时定时器计数到了再重传



# HTTP
### 1.HTTP状态码
![Image](https://user-images.githubusercontent.com/91466593/144747980-dcbffc55-0f08-4728-9cf7-3b70c9b4aa7e.png)
### 2.http缓存策略
1. 缓存存储策略  
* 用来确定 Http 响应内容是否可以被客户端缓存，以及可以被哪些客户端缓存
这个策略的作用只有一个，用于决定 Http 响应内容是否可缓存到客户端
对 于 Cache-Control 头里的 Public、Private、no-cache、max-age 、no-store 他们都是用来指明响应内容是否可以被客户端存储的，其中前4个都会缓存文件数据（关于 no-cache 应理解为“不建议使用本地缓存”，其仍然会缓存数据到本地），后者 no-store 则不会在客户端缓存任何响应数据。另关于 no-cache 和 max-age 有点特别，我认为它是一种混合体，下面我会讲到。
通 过 Cache-Control：Public 设置我们可以将 Http 响应数据存储到本地，但此时并不意味着后续浏览器会直接从缓存中读取数据并使用，为啥？因为它无法确定本地缓存的数据是否可用（可能已经失效），还必须借 助一套鉴别机制来确认才行， 这就是我们下面要讲到的“缓存过期策略”。
2. 缓存过期策略  
* 客户端用来确认存储在本地的缓存数据是否已过期，进而决定是否要发请求到服务端获取数据
这个策略的作用也只有一个，那就是决定客户端是否可直接从本地缓存数据中加载数据并展示（否则就发请求到服务端获取）
刚 上面我们已经阐述了数据缓存到了本地后还需要经过判断才能使用，那么浏览器通过什么条件来判断呢？ 答案是：Expires，Expires 指名了缓存数据有效的绝对时间，告诉客户端到了这个时间点（比照客户端时间点）后本地缓存就作废了，在这个时间点内客户端可以认为缓存数据有效，可直接从 缓存中加载展示。
3. 缓存对比策略  
* 将缓存在客户端的数据标识发往服务端，服务端通过标识来判断客户端 缓存数据是否仍有效，进而决定是否要重发数据。
客 户端检测到数据过期或浏览器刷新后，往往会重新发起一个 http 请求到服务器，服务器此时并不急于返回数据，而是看请求头有没有带标识（ If-Modified-Since、If-None-Match）过来，如果判断标识仍然有效，则返回304告诉客户端取本地缓存数据来用即可（这里要 注意的是你必须要在首次响应时输出相应的头信息（Last-Modified、ETags）到客户端）。至此我们就明白了上面所说的本地缓存数据即使被认 为过期，并不等于数据从此就没用了的道理了。
### 3.HTTPS的原理是什么？具体的访问过程是什么？
1. 客户端向服务器端发起SSL连接请求； 
2. 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥 
3. 客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端 
4. 服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密， 
5. 进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改。
* 因为数字签名、摘要是证书防伪非常关键的武器。 “摘要”就是对传输的内容，通过hash算法计算出一段固定长度的串。然后，通过发送方的私钥对这段摘要进行加密，加密后得到的结果就是“数字签名”
* SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
### HTTP是连接的吗？举一个使用UDP协议的应用层协议
### DNS的应用层协议是什么？UDP HTTP的应用层协议是什么？
### 浏览器输入地址的流程
1. 查浏览器缓存，看看有没有已经缓存好的，如果没有
2. 检查本机host文件，
3. 调用API，Linux下Scoket函数 gethostbyname
4. 向DNS服务器发送DNS请求，查询本地DNS服务器，这其中用的是UDP的协议（ UDP快！UDP的DNS协议只要一个请求、一个应答就好了，虽然不能超过512字节，但是一般都不会超过）
5. 如果在一个子网内采用ARP地址解析协议进行ARP查询，如果不在一个子网那就需要对默认网关进行DNS查询，如果还找不到会一直向上找根DNS服务器，直到最终拿到IP地址
6. 这个时候我们就有了服务器的IP地址 以及默认的端口号了，http默认是80 https是 443 端口号，会，首先尝试http然后调用Socket建立TCP连接，
7. 经过三次握手成功建立连接后，开始传送数据，如果正是http协议的话，就返回就完事了，
8. 如果不是http协议，服务器会返回一个5开头的的重定向消息，告诉我们用的是https，那就是说IP没变，但是端口号从80变成443了，好了，再四次挥手，完事，
9. 再来一遍，这次除了上述的端口号从80变成443之外，还会采用SSL的加密技术来保证传输数据的安全性，保证数据传输过程中不被修改或者替换之类的，
10. 这次依然是三次握手，沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验对方的CA安全证书。
11. 确认无误后，开始通信，然后服务器就会返回你所要访问的网址的一些数据。
### 浏览器输入地址提示找不到ip地址，有哪些原因？出了什么问题？



